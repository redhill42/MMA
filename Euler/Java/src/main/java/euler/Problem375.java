package euler;

import static euler.algo.Library.modmul;

public final class Problem375 {
    private Problem375() {}

    private static final int SEED = 290797;
    private static final int MODULO = 50515093;

    // hard coded constants generated by findCycle()
    private static final int MINVAL = 3;
    private static final int CYCLE = 6308948;

    private static class Generator {
        private int seed = SEED;
        public int next() {
            seed = modmul(seed, seed, MODULO);
            return seed;
        }
    }

    @SuppressWarnings("unused")
    private static int findCycle() {
        Generator gen = new Generator();
        int minval = Integer.MAX_VALUE;
        int cycle = 0;

        for (;;) {
            int n = gen.next();
            if (n == minval)
                break;
            if (n < minval) {
                minval = n;
                cycle = 0;
            }
            cycle++;
        }
        return cycle;
    }

    public static long solve(long limit) {
        Generator gen = new Generator();
        int[]  stack = new int[1024];
        long[] pos = new long[1024];
        int    top = 0;
        long   minimums = 0, partialMinimus = 0;
        long   sum = 0, partialSum = 0;
        long   total = 0;
        int    stage = 0;

        for (long i = 1; i <= limit; i++) {
            int n = gen.next();

            if (n == MINVAL) {
                switch (stage) {
                case 0: // first cycle encountered
                    total += sum;
                    sum = 0;
                    stage++;
                    break;

                case 1: // first cycle ended
                    partialSum = sum;
                    partialMinimus = minimums;
                    total += sum;
                    sum = 0;
                    stage++;
                    break;

                case 2: // second cycle ended, we now have increments
                    long skip = (limit - i) / CYCLE;

                    // update state
                    i += skip * CYCLE;
                    for (int j = 0; j < top; j++)
                        pos[j] += skip * CYCLE;
                    minimums += (minimums - partialMinimus) * skip;

                    // skip cycles
                    total += (skip + 1) * sum + skip * (skip + 1) / 2 * (sum - partialSum);
                    sum = 0;
                    stage++;
                    break;
                }
            }

            long last = i;
            while (top > 0 && n <= stack[top - 1]) {
                top--;
                minimums -= (last - pos[top]) * stack[top];
                last = pos[top];
            }

            stack[top] = n;
            pos[top] = last;
            top++;

            minimums += (i + 1 - last) * n;
            sum += minimums;
        }

        return total + sum;
    }

    public static void main(String[] args) {
        long n = 2_000_000_000;
        if (args.length > 0)
            n = Long.parseLong(args[0]);
        System.out.println(solve(n));
    }
}
